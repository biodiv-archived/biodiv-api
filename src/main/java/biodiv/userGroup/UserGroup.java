package biodiv.userGroup;
// Generated 31 Jul, 2017 7:18:53 AM by Hibernate Tools 3.5.0.Final

import java.io.IOException;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.UniqueConstraint;

import org.hibernate.validator.constraints.NotBlank;

import com.fasterxml.jackson.core.JsonGenerationException;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Splitter;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.PrecisionModel;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKTReader;

import biodiv.common.Language;
import biodiv.observation.Observation;

/**
 * UserGroup generated by hbm2java
 */
@Entity
@Table(name = "user_group", schema = "public", uniqueConstraints = { @UniqueConstraint(columnNames = "name"),
		@UniqueConstraint(columnNames = "webaddress") })
public class UserGroup implements java.io.Serializable {

	private long id;
	private Language language;
	private boolean allowMembersToMakeSpeciesCall;
	private boolean allowNonMembersToComment;
	private boolean allowObvCrossPosting;
	private boolean allowUsersToJoin;
	private String description;
	private String domainName;
	private Date foundedOn;
	private String homePage;
	private String icon;
	private boolean isDeleted;
	private String name;
	private float neLatitude;
	private float neLongitude;
	private float swLatitude;
	private float swLongitude;
	private String theme;
	private long visitCount;
	private String webaddress;
	private boolean sendDigestMail;
	private Date statStartDate = new Date();
	private String filterRule;
	

	public UserGroup() {
	}

	public UserGroup(long id, Language language, boolean allowMembersToMakeSpeciesCall,
			boolean allowNonMembersToComment, boolean allowObvCrossPosting, boolean allowUsersToJoin,
			String description, Date foundedOn, boolean isDeleted, String name, float neLatitude, float neLongitude,
			float swLatitude, float swLongitude, long visitCount, String webaddress, boolean sendDigestMail,
			Date statStartDate) {
		this.id = id;
		this.language = language;
		this.allowMembersToMakeSpeciesCall = allowMembersToMakeSpeciesCall;
		this.allowNonMembersToComment = allowNonMembersToComment;
		this.allowObvCrossPosting = allowObvCrossPosting;
		this.allowUsersToJoin = allowUsersToJoin;
		this.description = description;
		this.foundedOn = foundedOn;
		this.isDeleted = isDeleted;
		this.name = name;
		this.neLatitude = neLatitude;
		this.neLongitude = neLongitude;
		this.swLatitude = swLatitude;
		this.swLongitude = swLongitude;
		this.visitCount = visitCount;
		this.webaddress = webaddress;
		this.sendDigestMail = sendDigestMail;
		this.statStartDate = statStartDate;
	}

	public UserGroup(long id, Language language, boolean allowMembersToMakeSpeciesCall,
			boolean allowNonMembersToComment, boolean allowObvCrossPosting, boolean allowUsersToJoin,
			String description, String domainName, Date foundedOn, String homePage, String icon, boolean isDeleted,
			String name, float neLatitude, float neLongitude, float swLatitude, float swLongitude, String theme,
			long visitCount, String webaddress, boolean sendDigestMail, Date statStartDate, String filterRule
			) {
		this.id = id;
		this.language = language;
		this.allowMembersToMakeSpeciesCall = allowMembersToMakeSpeciesCall;
		this.allowNonMembersToComment = allowNonMembersToComment;
		this.allowObvCrossPosting = allowObvCrossPosting;
		this.allowUsersToJoin = allowUsersToJoin;
		this.description = description;
		this.domainName = domainName;
		this.foundedOn = foundedOn;
		this.homePage = homePage;
		this.icon = icon;
		this.isDeleted = isDeleted;
		this.name = name;
		this.neLatitude = neLatitude;
		this.neLongitude = neLongitude;
		this.swLatitude = swLatitude;
		this.swLongitude = swLongitude;
		this.theme = theme;
		this.visitCount = visitCount;
		this.webaddress = webaddress;
		this.sendDigestMail = sendDigestMail;
		this.statStartDate = statStartDate;
		this.filterRule = filterRule;
	
	}

	@Id

	@Column(name = "id", unique = true, nullable = false)
	@NotBlank
	public long getId() {
		return this.id;
	}

	public void setId(long id) {
		this.id = id;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "language_id", nullable = false)
	public Language getLanguage() {
		return this.language;
	}

	public void setLanguage(Language language) {
		this.language = language;
	}

	@Column(name = "allow_members_to_make_species_call", nullable = false)
	public boolean isAllowMembersToMakeSpeciesCall() {
		return this.allowMembersToMakeSpeciesCall;
	}

	public void setAllowMembersToMakeSpeciesCall(boolean allowMembersToMakeSpeciesCall) {
		this.allowMembersToMakeSpeciesCall = allowMembersToMakeSpeciesCall;
	}

	@Column(name = "allow_non_members_to_comment", nullable = false)
	public boolean isAllowNonMembersToComment() {
		return this.allowNonMembersToComment;
	}

	public void setAllowNonMembersToComment(boolean allowNonMembersToComment) {
		this.allowNonMembersToComment = allowNonMembersToComment;
	}

	@Column(name = "allow_obv_cross_posting", nullable = false)
	public boolean isAllowObvCrossPosting() {
		return this.allowObvCrossPosting;
	}

	public void setAllowObvCrossPosting(boolean allowObvCrossPosting) {
		this.allowObvCrossPosting = allowObvCrossPosting;
	}

	@Column(name = "allow_users_to_join", nullable = false)
	public boolean isAllowUsersToJoin() {
		return this.allowUsersToJoin;
	}

	public void setAllowUsersToJoin(boolean allowUsersToJoin) {
		this.allowUsersToJoin = allowUsersToJoin;
	}

	@Column(name = "description", columnDefinition="text", nullable = false)
	@NotBlank
	public String getDescription() {
		return this.description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	@Column(name = "domain_name")
	public String getDomainName() {
		return this.domainName;
	}

	public void setDomainName(String domainName) {
		this.domainName = domainName;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "founded_on", nullable = false, length = 29)
	public Date getFoundedOn() {
		return this.foundedOn;
	}

	public void setFoundedOn(Date foundedOn) {
		this.foundedOn = foundedOn;
	}

	@Column(name = "home_page")
	public String getHomePage() {
		return this.homePage;
	}

	public void setHomePage(String homePage) {
		this.homePage = homePage;
	}

	@Column(name = "icon")
	public String getIcon() {
		return this.icon;
	}

	public void setIcon(String icon) {
		this.icon = icon;
	}

	@Column(name = "is_deleted", nullable = false)
	public boolean isIsDeleted() {
		return this.isDeleted;
	}

	public void setIsDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	@Column(name = "name", unique = true, nullable = false)
	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Column(name = "ne_latitude", nullable = false, precision = 8, scale = 8)
	public float getNeLatitude() {
		return this.neLatitude;
	}

	public void setNeLatitude(float neLatitude) {
		this.neLatitude = neLatitude;
	}

	@Column(name = "ne_longitude", nullable = false, precision = 8, scale = 8)
	public float getNeLongitude() {
		return this.neLongitude;
	}

	public void setNeLongitude(float neLongitude) {
		this.neLongitude = neLongitude;
	}

	@Column(name = "sw_latitude", nullable = false, precision = 8, scale = 8)
	public float getSwLatitude() {
		return this.swLatitude;
	}

	public void setSwLatitude(float swLatitude) {
		this.swLatitude = swLatitude;
	}

	@Column(name = "sw_longitude", nullable = false, precision = 8, scale = 8)
	public float getSwLongitude() {
		return this.swLongitude;
	}

	public void setSwLongitude(float swLongitude) {
		this.swLongitude = swLongitude;
	}

	@Column(name = "theme")
	public String getTheme() {
		return this.theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	@Column(name = "visit_count", nullable = false)
	public long getVisitCount() {
		return this.visitCount;
	}

	public void setVisitCount(long visitCount) {
		this.visitCount = visitCount;
	}

	@Column(name = "webaddress", unique = true, nullable = false)
	@NotBlank
	public String getWebaddress() {
		return this.webaddress;
	}

	public void setWebaddress(String webaddress) {
		this.webaddress = webaddress;
	}

	@Column(name = "send_digest_mail", nullable = false)
	public boolean isSendDigestMail() {
		return this.sendDigestMail;
	}

	public void setSendDigestMail(boolean sendDigestMail) {
		this.sendDigestMail = sendDigestMail;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "stat_start_date", nullable = false, length = 29)
	public Date getStatStartDate() {
		return this.statStartDate;
	}

	public void setStatStartDate(Date statStartDate) {
		this.statStartDate = statStartDate;
	}

	@Column(name = "filter_rule")
	public String getFilterRule() {
		return this.filterRule;
	}

	public void setFilterRule(String filterRule) {
		this.filterRule = filterRule;
	}

	@Override
	public boolean equals(Object other) {
		if ((this == other))
			return true;
		if ((other == null))
			return false;
		if (!(other instanceof UserGroup))
			return false;
		UserGroup castOther = (UserGroup) other;

		return (this.getId() == castOther.getId());
	}
	
	@Override
	public int hashCode() {
		int result = 17;

		result = 37 * result + (int) this.getId();
		return result;
	}
/*	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "user_group_documents", schema = "public", joinColumns = {
			@JoinColumn(name = "user_group_id", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "document_id", nullable = false, updatable = false) })
	public Set getDocuments() {
		return this.documents;
	}

	public void setDocuments(Set documents) {
		this.documents = documents;
	}

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "user_group_projects", schema = "public", joinColumns = {
			@JoinColumn(name = "user_group_id", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "project_id", nullable = false, updatable = false) })
	public Set getProjects() {
		return this.projects;
	}

	public void setProjects(Set projects) {
		this.projects = projects;
	}

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "user_group_species", schema = "public", joinColumns = {
			@JoinColumn(name = "user_group_id", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "species_id", nullable = false, updatable = false) })
	public Set getSpecieses() {
		return this.specieses;
	}

	public void setSpecieses(Set specieses) {
		this.specieses = specieses;
	}

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "user_group_observations", schema = "public", joinColumns = {
			@JoinColumn(name = "user_group_id", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "observation_id", nullable = false, updatable = false) })
	public Set getObservations() {
		return this.observations;
	}

	public void setObservations(Set observations) {
		this.observations = observations;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getUserGroupHabitats() {
		return this.userGroupHabitats;
	}

	public void setUserGroupHabitats(Set userGroupHabitats) {
		this.userGroupHabitats = userGroupHabitats;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getDigests() {
		return this.digests;
	}

	public void setDigests(Set digests) {
		this.digests = digests;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getUserGroupObservations() {
		return this.userGroupObservations;
	}

	public void setUserGroupObservations(Set userGroupObservations) {
		this.userGroupObservations = userGroupObservations;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getFeatureds() {
		return this.featureds;
	}

	public void setFeatureds(Set featureds) {
		this.featureds = featureds;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getCustomFields() {
		return this.customFields;
	}

	public void setCustomFields(Set customFields) {
		this.customFields = customFields;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getUserGroupNewsletters() {
		return this.userGroupNewsletters;
	}

	public void setUserGroupNewsletters(Set userGroupNewsletters) {
		this.userGroupNewsletters = userGroupNewsletters;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getUserGroupSpeciesGroups() {
		return this.userGroupSpeciesGroups;
	}

	public void setUserGroupSpeciesGroups(Set userGroupSpeciesGroups) {
		this.userGroupSpeciesGroups = userGroupSpeciesGroups;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getSuserUserGroups() {
		return this.suserUserGroups;
	}

	public void setSuserUserGroups(Set suserUserGroups) {
		this.suserUserGroups = suserUserGroups;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getUserGroupMemberRoles() {
		return this.userGroupMemberRoles;
	}

	public void setUserGroupMemberRoles(Set userGroupMemberRoles) {
		this.userGroupMemberRoles = userGroupMemberRoles;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "userGroup")
	public Set getNewsletters() {
		return this.newsletters;
	}

	public void setNewsletters(Set newsletters) {
		this.newsletters = newsletters;
	}

	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(name = "user_group_discussions", schema = "public", joinColumns = {
			@JoinColumn(name = "user_group_id", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "discussion_id", nullable = false, updatable = false) })
	public Set getDiscussions() {
		return this.discussions;
	}

	public void setDiscussions(Set discussions) {
		this.discussions = discussions;
	}
*/

	public static Set<UserGroup> findAllContainingObj(String objectType,Object object, Set<UserGroup> userGroupsWithFilterRule) throws JsonParseException, IOException, ParseException {
		
		Set<UserGroup> allGroupsContainingObv = new HashSet<UserGroup>();
		for(UserGroup ug : userGroupsWithFilterRule)
		{
			if(ug.filterRule != null)
			{		
				try{
						ObjectMapper mapper = new ObjectMapper();
						
						JsonNode rootNode = mapper.readValue(ug.filterRule, JsonNode.class);
						String field = "";
						String rule = "";
						JsonNode ruleValue = null;
						boolean belongs = false;
						for(int i=0; i<rootNode.size(); i++) {
							 field = rootNode.get(i).get("fieldName").asText();
							 rule = rootNode.get(i).get("ruleName").asText();	
							JsonNode ruleValues = rootNode.get(i).get("ruleValues");
							for(int j=0; j<ruleValues.size();j++) {
								 ruleValue = ruleValues.get(i);
								//System.out.println(ruleValue.asText());
							}
						}	
			
						if(field.equalsIgnoreCase("topology") && rule.equalsIgnoreCase("dwithin"))
						{	
							Geometry topology;
							Geometry boundary = convertToGeometry(ruleValue.asText());
							switch(objectType){
							
							case "biodiv.observation.Observation":
								
								topology = ((Observation) object).getTopology();
								belongs = Observation.obvIsWithinUserGroupBoundary(topology,boundary);
								
							default:
								//
							}
							
							
						}
						if(belongs == true)
						{
							allGroupsContainingObv.add(ug);
						}
					 
				}catch (JsonGenerationException e) {
					e.printStackTrace();
				} catch (JsonMappingException e) {
					e.printStackTrace();
				} catch (IOException e) {
					e.printStackTrace();
				}		
			 }			
		 }
		return allGroupsContainingObv;
	}

private static Geometry convertToGeometry(String ruleValue) throws ParseException {
	GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(),4326);
    WKTReader wkt = new WKTReader(geometryFactory);
    Geometry boundary = null;
    try {
    	 boundary = wkt.read(ruleValue);
    } catch(ParseException e) {
        e.printStackTrace();
    }
    //System.out.println("geometryyyyyyyyyyyyyyyyy" + boundary);
	return boundary;
}

public static <T> List<List<T>> collate( List<T> list, int size, int step ) {
    return Stream.iterate( 0, i -> i + step )
                    .limit( ( list.size() / step ) + 1 )
                    .map( i -> list.stream()
                                   .skip( i )
                                   .limit( size )
                                   .collect( Collectors.toList() ) )
                    .filter( i -> !i.isEmpty() )
                    .collect( Collectors.toList() ) ;
}

public static byte[][] splitBytes(final byte[] data, final int chunkSize)
{
  final int length = data.length;
  final byte[][] dest = new byte[(length + chunkSize - 1)/chunkSize][];
  int destIndex = 0;
  int stopIndex = 0;

  for (int startIndex = 0; startIndex + chunkSize <= length; startIndex += chunkSize)
  {
    stopIndex += chunkSize;
    dest[destIndex++] = Arrays.copyOfRange(data, startIndex, stopIndex);
  }

  if (stopIndex < length)
    dest[destIndex] = Arrays.copyOfRange(data, stopIndex, length);

  return dest;
}


//public Map<String, List<String>> splitQuery(URL url) {
//    if (Strings.isNullOrEmpty(url.getQuery())) {
//        return Collections.emptyMap();
//    }
//    return Arrays.stream(url.getQuery().split("&"))
//            .map(this::splitQueryParameter)
//            .collect(Collectors.groupingBy(SimpleImmutableEntry::getKey, LinkedHashMap::new, mapping(Map.Entry::getValue, toList())));
//}
//
//public SimpleImmutableEntry<String, String> splitQueryParameter(String it) {
//    final int idx = it.indexOf("=");
//    final String key = idx > 0 ? it.substring(0, idx) : it;
//    final String value = idx > 0 && it.length() > idx + 1 ? it.substring(idx + 1) : null;
//    return new SimpleImmutableEntry<>(key, value);
//}

public static Map<String, String> filterUrlParser(String uri){
	String query =  uri.split("\\?")[1];
	Map<String, String> map = Splitter.on('&').trimResults().withKeyValueSeparator("=").split(query);
	return map;
}

public static String getActivityObjectType(Object obj,String submitType,String rootHolderType,Long count) {
	
	String type = obj.getClass().getSimpleName();
	String result = "";
	
	switch(type){

	case "Observation":
		if(rootHolderType.equalsIgnoreCase("UserGroup")){		
			result = submitType.equalsIgnoreCase("post")?("Posted "+ count + " observation(s) to group"):("Removed "+ count +" observation(s) from group");
			
		}else{
			result = submitType.equalsIgnoreCase("post")?"Posted observation to group":"Removed observation from group";
		}
		break;
	
	default:
		//
	}
	return result;

}

}
